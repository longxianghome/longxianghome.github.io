<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>记录 总结 思考 成长</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="记录 总结 思考 成长">
<meta property="og:url" content="http://longxianghome.com/page/2/index.html">
<meta property="og:site_name" content="记录 总结 思考 成长">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="记录 总结 思考 成长">
  
    <link rel="alternate" href="/atom.xml" title="记录 总结 思考 成长" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">记录 总结 思考 成长</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java Web 开发</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://longxianghome.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-20180620-一个统计需求的解决过程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/20/20180620-一个统计需求的解决过程/" class="article-date">
  <time datetime="2018-06-20T15:49:24.000Z" itemprop="datePublished">2018-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作积累/">工作积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/20/20180620-一个统计需求的解决过程/">一个统计需求的解决过程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做统计相关的需求: </p>
<ul>
<li>按年月日分组统计客户的采购金额</li>
<li>按年月分组统计客户的采购金额</li>
<li>按年分组统计客户的采购金额</li>
</ul>
<p>准备将其中遇到的问题，解决思路，以及相关知识做一个复盘，记录。</p>
<p>首先看到这个需求，第一印象是使用分组统计的方式来完成，其大致的 SQL 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	customer_org_id,</span><br><span class="line">	customer_org_name,</span><br><span class="line">	DATE_FORMAT(add_time, &apos;%Y-%m-%d&apos;) y-m-d,</span><br><span class="line">	SUM(form_amount) amount</span><br><span class="line">FROM</span><br><span class="line">	order_purchase_info</span><br><span class="line">GROUP BY</span><br><span class="line">	customer_org_id,</span><br><span class="line">	customer_org_name,</span><br><span class="line">	y-m-d</span><br><span class="line">ORDER BY</span><br><span class="line">	customer_org_name,</span><br><span class="line">	y-m-d</span><br></pre></td></tr></table></figure></p>
<p>只需要按不同的统计维度，修改一下分组条件即可。<br>但是实际从统计结果中发现一个问题，实际客户数据是不连续的，特别是按年月日分组统计，有些客户可能某天没有发生采购</p>
<p>那么此时需要想办法将数据补全，补全一般来说有两种方式：</p>
<ol>
<li>数据库中补全</li>
<li>应用程序补全</li>
</ol>
<p>初步打算是通过数据库补全，通过网上查找资料，提到一种方法就是通过日期表来做联合查询使数据完整。</p>
<p>不过很多日期表的实现里面都提到了用 CROSS JOIN 。</p>
<p>学习 CROSS JOIN 前，必须先了解一下 <strong>笛卡尔乘积</strong></p>
<p>笛卡尔乘积：<br>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。<br>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p>
<p>可以参考博文 <a href="http://www.cnblogs.com/chenxizhang/archive/2008/11/10/1330325.html" target="_blank" rel="noopener">CROSS JOIN</a></p>
<p>创建一个连续的数据表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE num ( i INT );</span><br><span class="line">INSERT INTO num ( i )</span><br><span class="line">VALUES</span><br><span class="line">	( 0 ),</span><br><span class="line">	( 1 ),</span><br><span class="line">	( 2 ),</span><br><span class="line">	( 3 ),</span><br><span class="line">	( 4 ),</span><br><span class="line">	( 5 ),</span><br><span class="line">	( 6 ),</span><br><span class="line">	( 7 ),</span><br><span class="line">	( 8 ),</span><br><span class="line">	( 9 );</span><br></pre></td></tr></table></figure></p>
<p>通过类似 SQL 获取连续日期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	adddate( &apos;2012-09-01&apos;, numlist.id ) AS `date` </span><br><span class="line">FROM</span><br><span class="line">	(</span><br><span class="line">SELECT</span><br><span class="line">	n1.i + n10.i * 10 + n100.i * 100 AS id </span><br><span class="line">FROM</span><br><span class="line">	num n1</span><br><span class="line">	CROSS JOIN num AS n10</span><br><span class="line">	CROSS JOIN num AS n100 </span><br><span class="line">	) AS numlist </span><br><span class="line">WHERE</span><br><span class="line">	adddate( &apos;2012-09-01&apos;, numlist.id ) &lt;= &apos;2012-09-10&apos;;</span><br></pre></td></tr></table></figure></p>
<p>有了连续的日期，只要和统计数据做一下关联查询即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://longxianghome.com/2018/06/20/20180620-一个统计需求的解决过程/" data-id="cjl6cd3qc00fc696byy6u38zw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作积累/">工作积累</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20180604-客户端配置多个 Git 账号" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/04/20180604-客户端配置多个 Git 账号/" class="article-date">
  <time datetime="2018-06-04T15:49:24.000Z" itemprop="datePublished">2018-06-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/工作积累/">工作积累</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/20180604-客户端配置多个 Git 账号/">客户端配置多个 Git 账号</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为公司使用 GitLab，而自己 GitHub 也有账号，目前笔记本可能需要两个都需要使用，故需要在笔记本上配置两个 Git 账号。</p>
<p><strong>生成秘钥</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>当出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/user_name/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>不要默认回车，输入一个唯一的名称，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id_rsa_github</span><br></pre></td></tr></table></figure></p>
<p>后续可以默认回车。</p>
<p>同理生成一个另一个秘钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls ~/.ssh</span><br></pre></td></tr></table></figure>
<p>应该出现例如如下列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id_rsa_github id_rsa_github.pub id_rsa_gitlab id_rsa_gitlab.pub</span><br></pre></td></tr></table></figure></p>
<p><strong>创建配置文件</strong></p>
<p>多 Git 账号需要依赖于一份配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ vim config</span><br></pre></td></tr></table></figure>
<p>配置文件中添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#gitlab</span><br><span class="line">Host gitlab.com</span><br><span class="line">  HostName gitlab.com</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_gitlab</span><br><span class="line"></span><br><span class="line">#github</span><br><span class="line">Host github.com</span><br><span class="line">  HostName github.com</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa_github</span><br></pre></td></tr></table></figure></p>
<p><strong>检查连接</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi einverne! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br><span class="line">$ ssh -T git@gitlab.com</span><br><span class="line">Welcome to GitLab, Ein Verne (einverne)!</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://longxianghome.com/2018/06/04/20180604-客户端配置多个 Git 账号/" data-id="cjl6cd3qe00fg696b2s38pok0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工作积累/">工作积累</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20180513-MySQL 索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/18/20180513-MySQL 索引/" class="article-date">
  <time datetime="2018-05-18T13:34:24.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/18/20180513-MySQL 索引/">MySQL 索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近做了一些系统优化，其中 SQL 优化占比不小，基本都是索引设置不当导致的。刚好趁此机会梳理一下 MySQL 索引的知识。<br>很多知识也是参考网上的相关资料。</p>
<p>数据库查询是数据库基本功能，期待的是查询速度越快越好，但是很多查找算法都是基于特定数据结构的，例如二分查找要求数据是有序的，二叉树查找只能应用于二叉树上。可是数据库的表结构是个行列的二维结构是固定的，所以数据库需要在数据之外为满足高性能的查找算法维护一个数据结构，这就是索引。</p>
<p>索引是在存储引擎中实现的，MySQL 不同的存储引擎支持的索引类型不一样。</p>
<table>
<thead>
<tr>
<th>索引类型</th>
<th>MyISAM 引擎</th>
<th>InnoDB 引擎</th>
<th>Memory 引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td>B-Tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>HASH 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-Tree 索引</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text 索引</td>
<td>不支持</td>
<td>暂不支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p>B-Tree 索引类型：</p>
<ul>
<li>普通索引</li>
<li>UNIQUE 索引</li>
<li>PRIMARY KEY 索引</li>
</ul>
<p><strong>索引创建原则</strong></p>
<ol>
<li>较频繁的作为查询条件的字段应该创建索引</li>
<li>唯一性太差的字段不适合单独创建索引</li>
<li>更新非常频繁的字段不适合创建索引</li>
<li>不会出现在 WHERE 子句中的字段不该创建索引</li>
</ol>
<p><strong>索引列选择原则</strong></p>
<ul>
<li>在 WHERE 子句中出现的列，在 JOIN 子句中出现的列</li>
<li>索引列的值相似度越低，索引效果越好</li>
<li>利用最左前缀</li>
<li>使用短索引</li>
</ul>
<p>MySQL 只对 <code>&lt;, &lt;=, =, &gt;, &gt;=, between, in</code> 以及不以通配符开头的 <code>like</code> 索引才生效<br>特别是 <code>null</code> 索引是不生效的</p>
<p><strong>组合索引和字段顺序</strong></p>
<p>转自：<a href="https://www.cnblogs.com/sunss/archive/2010/09/14/1826112.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunss/archive/2010/09/14/1826112.html</a></p>
<p>假设有一张订单表(orders)，包含order_id和product_id二个字段。<br>一共有31条数据。符合下面语句的数据有5条。</p>
<p>执行下面的sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id </span><br><span class="line">from orders</span><br><span class="line">where order_id in (123, 312, 223, 132, 224);</span><br></pre></td></tr></table></figure>
<p>这条语句要mysql去根据order_id进行搜索，然后返回匹配记录中的product_id。</p>
<p>所以组合索引应该按照以下的顺序创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create index orderid_productid on orders(order_id, product_id)</span><br><span class="line">mysql&gt; explain select product_id from orders where order_id in (123, 312, 223, 132, 224) \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: orders</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: orderid_productid</span><br><span class="line">          key: orderid_productid</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个组合索引被用到了,扫描的范围也很小，只有5行。</p>
<p>如果把组合索引的顺序换成product_id, order_id的话，<br>mysql就会去索引中搜索 <em>123 </em>312 <em>223 </em>132 *224，必然会有些慢了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index orderid_productid on orders(product_id, order_id);                                                       </span><br><span class="line">Query OK, 31 rows affected (0.01 sec)</span><br><span class="line">Records: 31  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select product_id from orders where order_id in (123, 312, 223, 132, 224) \G</span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: orders</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: orderid_productid</span><br><span class="line">      key_len: 10</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 31</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>这次索引搜索的性能显然不能和上次相比了。</p>
<p>rows:31，我的表中一共就31条数据。</p>
<p>索引被使用部分的长度：key_len:10，比上一次的key_len:5多了一倍。</p>
<p>不知道是这样在索引里面查找速度快，还是直接去全表扫描更快呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table orders add modify_a char(255) default &apos;aaa&apos;;</span><br><span class="line">Query OK, 31 rows affected (0.01 sec)</span><br><span class="line">Records: 31  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; explain select modify_a from orders where order_id in (123, 312, 223, 132, 224) \G          </span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: orders</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 31</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>这样就不会用到索引了。 刚才是因为select的product_id与where中的order_id都在索引里面的。</p>
<p>为什么要创建组合索引呢？这么简单的情况直接创建一个order_id的索引不就行了吗？<br>如果只有一个order_id索引，没什么问题，会用到这个索引，然后mysql要去磁盘上的表里面取到product_id。</p>
<p>如果有组合索引的话，mysql可以完全从索引中取到product_id，速度自然会快。</p>
<p>再多说几句组合索引的最左优先原则：<br>组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到。<br>如果有一个组合索引(col_a,col_b,col_c)</p>
<p>下面的情况都会用到这个索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">col_a = &quot;some value&quot;;</span><br><span class="line">col_a = &quot;some value&quot; and col_b = &quot;some value&quot;;</span><br><span class="line">col_a = &quot;some value&quot; and col_b = &quot;some value&quot; and col_c = &quot;some value&quot;;</span><br><span class="line">col_b = &quot;some value&quot; and col_a = &quot;some value&quot; and col_c = &quot;some value&quot;;</span><br></pre></td></tr></table></figure></p>
<p>对于最后一条语句，mysql会自动优化成第三条的样子~~。</p>
<p>下面的情况就不会用到索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col_b = &quot;aaaaaa&quot;;</span><br><span class="line">col_b = &quot;aaaa&quot; and col_c = &quot;cccccc&quot;;</span><br></pre></td></tr></table></figure></p>
<p>通过实例理解单列索引、多列索引以及最左前缀原则</p>
<p>实例：现在我们想查出满足以下条件的用户id：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT ｀uid｀ FROM people WHERE lname｀=&apos;Liu&apos;  AND ｀fname｀=&apos;Zhiqun&apos; AND ｀age｀=26</span><br></pre></td></tr></table></figure></p>
<p>因为我们不想扫描整表，故考虑用索引。</p>
<p>单列索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE people ADD INDEX lname (lname);</span><br></pre></td></tr></table></figure></p>
<p>将lname列建索引，这样就把范围限制在lname=’Liu’的结果集1上，之后扫描结果集1，产生满足fname=’Zhiqun’的结果集2，再扫描结果集2，找到 age=26的结果集3，即最终结果。</p>
<p>由 于建立了lname列的索引，与执行表的完全扫描相比，效率提高了很多，但我们要求扫描的记录数量仍旧远远超过了实际所需 要的。虽然我们可以删除lname列上的索引，再创建fname或者age 列的索引，但是，不论在哪个列上创建索引搜索效率仍旧相似。</p>
<p>2.多列索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</span><br></pre></td></tr></table></figure></p>
<p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p>
<p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p>
<p>3.最左前缀：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p>
<p>注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://longxianghome.com/2018/05/18/20180513-MySQL 索引/" data-id="cjl6cd3q300eo696bu7oy9y0l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20180510-MySQL 性能优化神器 Explain 使用分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/20180510-MySQL 性能优化神器 Explain 使用分析/" class="article-date">
  <time datetime="2018-05-10T15:57:24.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/20180510-MySQL 性能优化神器 Explain 使用分析/">MySQL 性能优化神器 Explain 使用分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文转自<a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>MySQL</strong> 提供了一个 EXPLAIN 命令, 它可以对 <strong>SELECT</strong> 语句进行分析, 并输出 <strong>SELECT</strong> 执行的详细信息, 以供开发人员针对性优化.<br><strong>EXPLAIN</strong> 命令用法十分简单, 在 <strong>SELECT</strong> 语句前加上 <strong>Explain</strong> 就可以了, 例如:</p>
<p><strong>EXPLAIN SELECT * from user_info WHERE id &lt; 300;</strong></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 <strong>EXPLAIN</strong> 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `age`  INT(11)              DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_index` (`name`)</span><br><span class="line">)</span><br><span class="line">  ENGINE = InnoDB</span><br><span class="line">  DEFAULT CHARSET = utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);</span><br><span class="line">INSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `order_info` (</span><br><span class="line">  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id`      BIGINT(20)           DEFAULT NULL,</span><br><span class="line">  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  `productor`    VARCHAR(30)          DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br><span class="line">)</span><br><span class="line">  ENGINE = InnoDB</span><br><span class="line">  DEFAULT CHARSET = utf8</span><br><span class="line"></span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);</span><br><span class="line">INSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p><strong>EXPLAIN</strong> 命令的输出内容大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>各列的含义如下:</p>
<ul>
<li><p>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p>
</li>
<li><p>select_type: SELECT 查询的类型.</p>
</li>
<li><p>table: 查询的是哪个表</p>
</li>
<li><p>partitions: 匹配的分区</p>
</li>
<li><p>type: join 类型</p>
</li>
<li><p>possible_keys: 此次查询中可能选用的索引</p>
</li>
<li><p>key: 此次查询中确切使用到的索引.</p>
</li>
<li><p>ref: 哪个字段或常数与 key 一起被使用</p>
</li>
<li><p>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</p>
</li>
<li><p>filtered: 表示此查询条件所过滤的数据的百分比</p>
</li>
<li><p>extra: 额外的信息</p>
</li>
</ul>
<p>接下来我们来重点看一下比较重要的几个字段.</p>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><strong>select_type</strong> 表示了查询的类型, 它的常用取值有:</p>
<ul>
<li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p>
</li>
<li><p>PRIMARY, 表示此查询是最外层的查询</p>
</li>
<li><p>UNION, 表示此查询是 UNION 的第二或随后的查询</p>
</li>
<li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p>
</li>
<li><p>UNION RESULT, UNION 的结果</p>
</li>
<li><p>SUBQUERY, 子查询中的第一个 SELECT</p>
</li>
<li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p>
</li>
</ul>
<p>最常见的查询类别应该是 <strong>SIMPLE</strong> 了, 比如当我们的查询没有子查询, 也没有 <strong>UNION</strong> 查询时, 那么通常就是 <strong>SIMPLE</strong> 类型, 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果我们使用了 <strong>UNION</strong> 查询, 那么 <strong>EXPLAIN</strong> 输出 的结果类似如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));</span><br><span class="line">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |</span><br><span class="line">|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><strong>type</strong> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <strong>type</strong> 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.</p>
<p><strong>type</strong> 常用的取值有:</p>
<ul>
<li><p>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</p>
</li>
<li><p>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <strong>type</strong> 就是 <strong>const</strong> 类型的.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>eq_ref: 此类型通常出现在多表的 <strong>join</strong> 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <strong>=</strong>, 查询效率较高. 例如:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 314</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: eq_ref</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: test.order_info.user_id</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>ref: 此类型通常出现在多表的 <strong>join</strong> 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 <strong>ref</strong> 类型的查询:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 9</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 <strong>=</strong>, <strong>&lt;&gt;</strong>, <strong>&gt;</strong>, <strong>&gt;=</strong>, <strong>&lt;</strong>, <strong>&lt;=</strong>, <strong>IS NULL</strong>, <strong>&lt;=&gt;</strong>, <strong>BETWEEN</strong>, <strong>IN()</strong> 操作中. 当 <strong>type</strong> 是 <strong>range</strong> 时, 那么 <strong>EXPLAIN</strong> 输出的 <strong>ref</strong> 字段为 <strong>NULL</strong>, 并且 <strong>key_len</strong> 字段是此次查询中使用到的索引的最长的那个.</li>
</ul>
<p>例如下面的例子就是一个范围查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT *</span><br><span class="line">    -&gt;         FROM user_info</span><br><span class="line">    -&gt;         WHERE id BETWEEN 2 AND 8 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li>index: 表示全索引扫描(<strong>full index scan</strong>), 和 <strong>ALL</strong> 类型类似, 只不过 <strong>ALL</strong> 类型是全表扫描, 而 <strong>index</strong> 类型则仅仅扫描所有的索引, 而不扫描数据.<br><strong>index</strong> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, <strong>Extra</strong> 字段 会显示 <strong>Using index</strong>.</li>
</ul>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM  user_info \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: name_index</span><br><span class="line">      key_len: 152</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, <strong>type</strong> 的值是 <strong>index</strong>, 并且 <strong>Extra</strong> 的值是 <strong>Using index</strong>.</p>
<ul>
<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 <strong>ALL</strong> 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 <strong>ALL</strong> 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, <strong>possible_keys</strong> 和 <strong>key</strong> 字段都是 <strong>NULL</strong>, 表示没有使用到索引, 并且 <strong>rows</strong> 十分巨大, 因此整个查询效率是十分低下的.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 10</span><br><span class="line">     filtered: 10.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:</p>
<p><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p>
<p><strong>ALL</strong> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 <strong>index</strong> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 <strong>ALL</strong> 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p>
<h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><strong>possible_keys</strong> 表示 <strong>MySQL</strong> 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <strong>possible_keys</strong> 中出现, 但是并不表示此索引会真正地被 <strong>MySQL</strong> 使用到. <strong>MySQL</strong> 在查询时具体使用了哪些索引, 由 <strong>key</strong> 字段决定.</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 <strong>MySQL</strong> 在当前查询时所真正使用到的索引.</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到. 的计算规则如下:</p>
<p><strong>字符串</strong></p>
<ul>
<li><p>char(n): n 字节长度</p>
</li>
<li><p>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</p>
</li>
</ul>
<p><strong>数值类型</strong></p>
<ul>
<li><p>TINYINT: 1字节</p>
</li>
<li><p>SMALLINT: 2字节</p>
</li>
<li><p>MEDIUMINT: 3字节</p>
</li>
<li><p>INT: 4字节</p>
</li>
<li><p>BIGINT: 8字节</p>
</li>
</ul>
<p><strong>时间类型</strong></p>
<ul>
<li><p>DATE: 3字节</p>
</li>
<li><p>TIMESTAMP: 4字节</p>
</li>
<li><p>DATETIME: 8字节</p>
</li>
</ul>
<p><strong>字段属性</strong></p>
<p>NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p>
<p>我们来举两个简单的栗子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 9</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5</span><br><span class="line">     filtered: 11.11</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>上面的例子是从表 <code>order_info</code> 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>
<p>KEY <code>user_product_detail_index</code> (<code>user_id</code>, <code>product_name</code>, <code>productor</code>)<br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</p>
<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>
<p>接下来我们来看一下下一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 161</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 2</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<p>Using filesort<br>当 <code>Extra</code>中有 <code>Using filesort</code>时, 表示 <strong>MySQL</strong> 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</p>
<p>例如下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 253</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index; Using filesort</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>我们的索引是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure>
<p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生<code>Using filesort.</code> 如果我们将排序依据改为 <code>ORDER BY user_id, product_name,</code>那么就不会出现 <code>Using filesort</code>了. 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: user_product_detail_index</span><br><span class="line">      key_len: 253</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 9</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Using index</p>
<p>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p>
</li>
<li><p>Using temporary</p>
<p>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://longxianghome.com/2018/05/10/20180510-MySQL 性能优化神器 Explain 使用分析/" data-id="cjl6cd3q400es696bkmypo3u9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-20180509-MySQL 查询优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/20180509-MySQL 查询优化/" class="article-date">
  <time datetime="2018-05-09T14:57:24.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/20180509-MySQL 查询优化/">MySQL 查询优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MySQL 5.7+</p>
<p>如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。<br><br>如果要优化查询，实际上要优化其子任务，优化的方式如下：<br></p>
<ul>
<li>要么消除其中一些子任务</li>
<li>要么减少子任务的执行次数</li>
<li>要么让子任务执行的更快</li>
</ul>
<h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><ul>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。</li>
<li>确认 MySQL 服务器层是否在分析大量超过需求的数据行。</li>
</ul>
<p><strong>是否向数据库请求了不需要的数据</strong></p>
<ul>
<li>查询不需要的计量</li>
<li>多表关联时返回全部的列</li>
<li>总是取出全部列</li>
<li>重复查询相同的数据</li>
</ul>
<p><strong>MySQL 是否在扫描额外的计量</strong></p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><ul>
<li>一个复杂查询还是多个简单查询</li>
<li>切分查询</li>
<li>分解关联查询</li>
</ul>
<p><strong>分解关联查询的优势</strong>：</p>
<ul>
<li>让缓存的效率更高</li>
<li>将查询分解后，执行单个查询可以减少锁的竞争</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</li>
<li>查询本身效率也可能会有所提升</li>
<li>可以减少冗余计量的查询</li>
<li>相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套循环关联</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://longxianghome.com/2018/05/09/20180509-MySQL 查询优化/" data-id="cjl6cd3pw00e8696b3tx8nebe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CI/">CI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gitflow/">Gitflow</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK/">JDK</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK-源码-1-7/">JDK 源码 1.7</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK-源码-1-8-0-161/">JDK 源码 1.8.0_161</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JIRA/">JIRA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JPA/">JPA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Collections-Framework/">Java Collections Framework</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Concurrent/">Java Concurrent</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Servlet/">Java Servlet</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Thread/">Java Thread</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-算法/">Java 算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis-原理/">MyBatis 原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyCAT/">MyCAT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Framework/">Spring Framework</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Security/">Spring Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web-安全/">Web 安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ZooKeeper/">ZooKeeper</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《Java-核心技术-36-讲》专栏笔记/">《Java 核心技术 36 讲》专栏笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《深入拆解-Java-虚拟机》专栏笔记/">《深入拆解 Java 虚拟机》专栏笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《深入理解Java虚拟机》/">《深入理解Java虚拟机》</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作积累/">工作积累</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/行业知识/">行业知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/">ArrayList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CI/">CI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CI-持续集成/">CI 持续集成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSRF/">CSRF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Collection/">Collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Comparable/">Comparable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Comparator/">Comparator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ExceptionHandler/">ExceptionHandler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GS1/">GS1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitflow/">Gitflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Iterator/">Iterator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/">JDK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK-8/">JDK 8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JIRA/">JIRA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Collections-Framework/">Java Collections Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-IO-Framework/">Java IO Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-Thread/">Java Thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java-虚拟机/">Java 虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java虚拟机/">Java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/">Jenkins</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyCAT/">MyCAT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantLock/">ReentrantLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RestTemplate/">RestTemplate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Servlet/">Servlet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shadowsocks/">Shadowsocks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sonatype-Nexus/">Sonatype Nexus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Framework/">Spring Framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Security/">Spring Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadLocal/">ThreadLocal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS/">XSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZooKeeper/">ZooKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/冒泡排序/">冒泡排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/包装类/">包装类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单例模式/">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作积累/">工作积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/持续集成/">持续集成</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插入排序/">插入排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程/">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/适配器模式/">适配器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/选择排序/">选择排序</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ArrayList/" style="font-size: 10px;">ArrayList</a> <a href="/tags/CI/" style="font-size: 11.82px;">CI</a> <a href="/tags/CI-持续集成/" style="font-size: 10px;">CI 持续集成</a> <a href="/tags/CSRF/" style="font-size: 10px;">CSRF</a> <a href="/tags/Collection/" style="font-size: 10px;">Collection</a> <a href="/tags/Comparable/" style="font-size: 10px;">Comparable</a> <a href="/tags/Comparator/" style="font-size: 10px;">Comparator</a> <a href="/tags/ExceptionHandler/" style="font-size: 10px;">ExceptionHandler</a> <a href="/tags/GS1/" style="font-size: 10.91px;">GS1</a> <a href="/tags/Gitflow/" style="font-size: 10px;">Gitflow</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Iterator/" style="font-size: 10px;">Iterator</a> <a href="/tags/JDK/" style="font-size: 10px;">JDK</a> <a href="/tags/JDK-8/" style="font-size: 12.73px;">JDK 8</a> <a href="/tags/JIRA/" style="font-size: 10px;">JIRA</a> <a href="/tags/JPA/" style="font-size: 17.27px;">JPA</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java-Collections-Framework/" style="font-size: 10px;">Java Collections Framework</a> <a href="/tags/Java-IO-Framework/" style="font-size: 14.55px;">Java IO Framework</a> <a href="/tags/Java-Thread/" style="font-size: 18.18px;">Java Thread</a> <a href="/tags/Java-虚拟机/" style="font-size: 11.82px;">Java 虚拟机</a> <a href="/tags/Java虚拟机/" style="font-size: 10.91px;">Java虚拟机</a> <a href="/tags/Jenkins/" style="font-size: 10px;">Jenkins</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 20px;">MyBatis</a> <a href="/tags/MyCAT/" style="font-size: 10px;">MyCAT</a> <a href="/tags/MySQL/" style="font-size: 16.36px;">MySQL</a> <a href="/tags/Python/" style="font-size: 14.55px;">Python</a> <a href="/tags/Redis/" style="font-size: 10.91px;">Redis</a> <a href="/tags/ReentrantLock/" style="font-size: 10px;">ReentrantLock</a> <a href="/tags/RestTemplate/" style="font-size: 10px;">RestTemplate</a> <a href="/tags/Servlet/" style="font-size: 11.82px;">Servlet</a> <a href="/tags/Shadowsocks/" style="font-size: 10px;">Shadowsocks</a> <a href="/tags/Sonatype-Nexus/" style="font-size: 10px;">Sonatype Nexus</a> <a href="/tags/Spring-Boot/" style="font-size: 19.09px;">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 16.36px;">Spring Cloud</a> <a href="/tags/Spring-Framework/" style="font-size: 15.45px;">Spring Framework</a> <a href="/tags/Spring-Security/" style="font-size: 13.64px;">Spring Security</a> <a href="/tags/ThreadLocal/" style="font-size: 10px;">ThreadLocal</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/ZooKeeper/" style="font-size: 10px;">ZooKeeper</a> <a href="/tags/冒泡排序/" style="font-size: 10px;">冒泡排序</a> <a href="/tags/包装类/" style="font-size: 10px;">包装类</a> <a href="/tags/单例模式/" style="font-size: 10.91px;">单例模式</a> <a href="/tags/工作积累/" style="font-size: 10.91px;">工作积累</a> <a href="/tags/持续集成/" style="font-size: 11.82px;">持续集成</a> <a href="/tags/插入排序/" style="font-size: 10px;">插入排序</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/适配器模式/" style="font-size: 10px;">适配器模式</a> <a href="/tags/选择排序/" style="font-size: 10px;">选择排序</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/08/20180808-Spring Security PasswordEncoder 相关源码阅读/">Spring Security PasswordEncoder 相关源码阅读</a>
          </li>
        
          <li>
            <a href="/2018/07/27/20180731-MySQL 事务隔离级别和悲观锁乐观锁原理/">MySQL 事务隔离级别和悲观锁乐观锁原理</a>
          </li>
        
          <li>
            <a href="/2018/07/27/20180727-JVM 如何执行方法调用的/">JVM 如何执行方法调用的</a>
          </li>
        
          <li>
            <a href="/2018/07/25/20180725-Java 虚拟机是如何加载 Java 类的/">Java 虚拟机是如何加载 Java 类的</a>
          </li>
        
          <li>
            <a href="/2018/07/20/20180720-Java 代码是怎么运行的/">Java 代码是怎么运行的</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 longxiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>